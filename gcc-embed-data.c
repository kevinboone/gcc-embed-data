/*==========================================================================

  gcc-embed-data

  A simple demonstration of how to embed a stringtable into an executable
  C program using features of GCC. The stringtable is a text file with
  lines of the form:

  number (space) some text of any length (LF)
  ...

  The strings might represent error messages, or menu text, or whatever.
  The function get_string (n) returns the string in the stringtable
  whose number is n.

  The key feature here is not the string-processing logic, which is trivial,
  but the technique for embedding the stringtable as raw binary data into
  the executable generated by gcc.

  Kevin Boone, June 2022. Please do with this code whatever you wish.

==========================================================================*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Note that stringtable_start 

// Note that 'asm("_binary_stringtable_txt_start")' is an _array_, not
//   a pointer. Athough C arrays and pointer may often be used 
//   interchangeably, this is a situation in which they can not.  
// In this context it would be incorrect -- and catastrophic -- to say 
//   "char *stringtable_start". Doing this would make the value of 
//   stringtable_start equal to the sequence of bytes stored at 
//   _binary_stringtable_txt_start. 
// Arrays are not pointers.
extern char stringtable_start[] asm("_binary_stringtable_txt_start");
extern char stringtable_end[] asm("_binary_stringtable_txt_end");

/*==========================================================================

  get_string

  Find a string in the stringtable whose numerical ID is n. Note that we
  absolutely would not want to implement a function like this in a real
  application -- we would read the stringtable at start-up, and cache the
  individual strings along with their IDs. This simple method works, but
  it potentially scans the entire stringtable every time somebody calls
  get_string().

  If a string with the supplied ID is found, it is returned as a newly-
  allocated char *. Otherwise, NULL is returned. The caller must free
  the string if it is not NULL.

==========================================================================*/
char *get_string (int n)
  {
  // Start the search at stringtable_start
  char *p = stringtable_start;
  // p_last will store the start of the string currently being
  //   examined
  char *p_last = p;
  // The return value, which will be set if the string's number matches
  char *ret = NULL;
  do 
    {
    if (*p == 10) // EOL
      {
      int string_len = p - p_last;
      char *string = malloc (string_len + 1);
      strncpy (string, p_last, string_len);
      string[string_len] = 0;
      int num = -1;
      // Read the string number from the line of text, and compare with
      //   the value of n supplied by the caller.
      sscanf (string, "%d", &num);
      if (num == n)
        {
        // The caller wants just the string, not the string number. So
        //   strip the number part off
        char *space = strchr (string, ' ');
        ret = strdup (space + 1);
        }
      free (string);
      p_last = p + 1;
      }
    p++;
    } while (p != stringtable_end && ret == NULL);
  return ret;
  }

/*==========================================================================

  main

  A simple demonstration how to call get_string

==========================================================================*/
int main (int argc, char **argv)
  {
  char *string;

  // Print the string whose ID is 100
  string = get_string (100);
  if (string)
    {
    printf ("This is string 100: %s\n", string);
    free (string);
    }

  // Print the string whose ID is 101
  string = get_string (101);
  if (string)
    {
    printf ("This is string 101: %s\n", string);
    free (string);
    }
  }


